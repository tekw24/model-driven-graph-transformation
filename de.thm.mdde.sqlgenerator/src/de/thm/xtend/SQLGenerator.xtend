package de.thm.xtend

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.core.runtime.IProgressMonitor
import org.eclipse.emf.ecore.EClass
import java.util.List
import de.thm.exception.GenerationCanceledException
import org.eclipse.emf.ecore.EReference
import java.util.ArrayList
import org.eclipse.core.resources.IFolder
import org.eclipse.core.resources.IFile
import java.io.InputStream
import java.io.ByteArrayInputStream
import org.eclipse.core.resources.IResource
import org.sidiff.difference.symmetric.SymmetricDifference
import org.sidiff.difference.symmetric.SemanticChangeSet
import de.thm.evolvedb.mdde.Database_Schema
import de.thm.evolvedb.migration.Migration
import de.thm.evolvedb.migration.ResolvableOperator
import de.thm.evolvedb.migration.ProcessStatus
import de.thm.evolvedb.migration.ResolvableOperatorType
import java.util.Arrays
import de.thm.evolvedb.mdde.DataType
import de.thm.evolvedb.migration.PartiallyResolvable
import de.thm.evolvedb.migration.PartiallyResolvableOperatorType
import de.thm.evolvedb.migration.NotAutomaticallyResolvable
import de.thm.evolvedb.migration.NotAutomaticallyResolvableOperatorType
import de.thm.evolvedb.migration.ColumnOptions

class SQLGenerator {

	// annotations
	/**
	 * Name for the AssociationClass annotation.
	 */
	final String ASSOCIATION_CLASS = "AssociationClass";
	/**
	 * Name for the AssociationEnd annotation.
	 */
	final String ASSOCIATION_END = "AssociationEnd";

	/**
	 * Name for the DisplayName annotation.
	 */
	final String DISPLAY_NAME = "DisplayName";

	boolean CHECK_CONSTRAINTS = false;

	/**
	 * The amount of work which has already been done.
	 */
	var int worked = 0;
	/**
	 * The total amount of work which has to be done.
	 */
	var int work = 75;

	/**
	 * Transactions that already have been visited.
	 */
	var List<SemanticChangeSet> processed;

	// For stats
	/**
	 * Count of generated bytes.
	 */
	var int generatedBytes = 0;
	/**
	 * Count of generated files.
	 */
	var int generatedFiles = 0;

	var long character = 0;

	public static String HISTORY_TABLE_NAME = "mdde_history";
	public static String TEMPORY_TABLE_NAME = "my_temp_id_table";

	// If the type is numeric, only digits are allowed.
	public var static List<DataType> numericTypes = Arrays.asList(DataType.BIGINT, DataType.DOUBLE, DataType.DECIMAL,
		DataType.DEC, DataType.FLOAT, DataType.INTEGER, DataType.MEDIUMINT, DataType.SMALLINT, DataType.TINYINT,
		DataType.BIGINT);

	public var static List<DataType> textTypes = Arrays.asList(DataType.CHAR, DataType.DATE, DataType.DATETIME,
		DataType.ENUM, DataType.LONGTEXT, DataType.MEDIUMTEXT, DataType.TEXT, DataType.VARCHAR, DataType.TINYTEXT,
		DataType.TIMESTAMP, DataType.TIME);

	/** 
	 * Generate the sql file.
	 */
	def String doGenerate(Resource resourceDifference, IProgressMonitor progressMonitor) {

		if (CHECK_CONSTRAINTS) {
			// check constraints
			// check if names are set
			for (EClass e : resourceDifference.allContents.toIterable.filter(typeof(EClass))) {
				for (a : e.EStructuralFeatures) {
					if (a.name === null) {
						throw new RuntimeException(a.toString)
					}
				}

			}

			// check if every AssociationClass are valid defined
			progressMonitor.subTask("Checking constraint: Whether every AssociationClasses are valid and sound");
			for (EClass e : resourceDifference.allContents.toIterable.filter(typeof(EClass)).filter[associationClass]) {
				var counter = 0
				for (EReference r : e.EReferences.filter[associationEnd]) {
					if (r.many) {
						throw new RuntimeException(
							"In AssociationClass " + e.name + " the AssociationEnd EReference " + r.name +
								" must not be many.");
					}
					counter++
				}
				if (counter != 2) {
					throw new RuntimeException("In AssociationClass " + e.name +
						" there must be two AssociationEnd annotated EReferences.");
				}
			}
			for (EReference a : resourceDifference.allContents.toIterable.filter(typeof(EReference)).filter [
				associationEnd
			]) {
				if (a.EContainingClass.associationClass == false) {
					throw new RuntimeException("In EClass " + a.EContainingClass.name +
						" are EReferences annotated with AssociationEnd, but the EClass is no AssociationClass.");
				}
			}
			makeProgressAndCheckCanceled(progressMonitor);

			// check if every EReference has EOpposite set
			progressMonitor.subTask("Checking constraint: Whether every EReference has an EOpposite");
			for (EClass e : resourceDifference.allContents.toIterable.filter(typeof(EClass))) {
				for (EReference r : e.EReferences) {
					if (r.EOpposite === null) {
						throw new RuntimeException("In EClass " + e.name + " the EReference " + r.name +
							" has no EOpposite set.");
					}
				}
			}
			makeProgressAndCheckCanceled(progressMonitor);

			// check for circle in DisplayName-Path
			progressMonitor.subTask("Checking constraint: No circle in DisplayName-path");
			for (EClass e : resourceDifference.allContents.toIterable.filter(typeof(EClass))) {
				checkCircleInDisplayNamePath(null, e, new ArrayList)
			}
			makeProgressAndCheckCanceled(progressMonitor);
		}

		var Migration migration = resourceDifference.allContents.findFirst[it instanceof Migration] as Migration
		var SymmetricDifference difference = migration.symmetricDifference

		var Resource modelB = difference.modelB

		// changes will be made in the schema described by the second model (modelB)
		var Database_Schema databaseSchemaB = modelB.allContents.
			findFirst[it instanceof Database_Schema] as Database_Schema

		var historyTable = migration.isHistoryTableRequired()

		var String content = '''
			USE «databaseSchemaB.name»;
			
			«IF historyTable»
				-- Creates an history table for deleted and updated values
				«ColumnUtil.createDataCleansingTable(HISTORY_TABLE_NAME, databaseSchemaB)»
			«ENDIF»		
		''';

		if (processed === null)
			processed = new ArrayList;

		// Solve resolvables first
		var List<ResolvableOperator> resolvableOperators = migration.resolvableSMO
		// Solve partiallyResolvable second
		var List<PartiallyResolvable> partiallyResolvable = migration.partiallyResovableSMO
		// Solve NotAutomaticallyResolvable third
		var List<NotAutomaticallyResolvable> notAutomaticallyResolvable = migration.notAutimaticallyResolvable

		var List<ResolvableOperatorType> ordererd = Arrays.asList(ResolvableOperatorType.REMOVE_CONSTRAINT, ResolvableOperatorType.CREATE_TABLE,
			ResolvableOperatorType.RENAME_TABLE, ResolvableOperatorType.CREATE_COLUMN,
			ResolvableOperatorType.RENAME_COLUMN, ResolvableOperatorType.CREATE_FOREIGN_KEY
			);

		for (ResolvableOperatorType type : ordererd) {
			var operators = resolvableOperators.filter[displayName === type]
			for (ResolvableOperator resolvable : operators) {

				if (resolvable.processStatus == ProcessStatus.RESOLVED) {
					var c = processResolvableOperator(resolvable);
					content += c !== null ? c : "";
				}
			}
			resolvableOperators.removeAll(operators);
		}

		

		var filteredpartiallyResolvable = partiallyResolvable.filter[processStatus == ProcessStatus.RESOLVED].toList
		// Execute changetype first
		var changeType = filteredpartiallyResolvable.filter [
			displayName === PartiallyResolvableOperatorType.SET_COLUMN_TYPE || displayName === PartiallyResolvableOperatorType.CREATE_PRIMARY_KEY
		]
		for (PartiallyResolvable presolvable : changeType) {
			var c = processPartiallyResolvableOperator(presolvable);
			content += c !== null ? c : "";
		}
		filteredpartiallyResolvable.removeAll(changeType)

		for (PartiallyResolvable presolvable : filteredpartiallyResolvable) {
			var c = processPartiallyResolvableOperator(presolvable);
			content += c !== null ? c : "";
		}
		
		for (ResolvableOperator resolvable : resolvableOperators) {

			if (resolvable.processStatus == ProcessStatus.RESOLVED) {
				var c = processResolvableOperator(resolvable);
				content += c !== null ? c : "";
			}
		}

		for (NotAutomaticallyResolvable naresolvable : notAutomaticallyResolvable) {
			if (naresolvable.processStatus == ProcessStatus.RESOLVED) {
				var c = processNotResolvableOperator(naresolvable);
				content += c !== null ? c : "";
			}
		}

		// resourceDifference.allContents.toIterable.filter(SemanticChangeSet)
		// process the changes in the correct order. 
//		for (var i = 0; i <= 5; i++) {
//			val index = i;
//			for (e : semanticChangeSets.filter[refinementLevel == index]) {
//				var c = processSemanticChangeSet(e);
//				content += c !== null ? c : "";
//			}
//
//		}
//		createFile(folder, "dump.sql", true, dump, progressMonitor);
		// createFile(folder, "test.sql", true, content, progressMonitor);
		content += '''
			-- If executing the script fails, we suggest a rollback.
		'''
		return content;

	// fsa.generateFile("\test.sql", content);
	}

	// The order doesn't matter.
	def String processResolvableOperator(ResolvableOperator resolvableOperator) {
		switch (resolvableOperator.displayName) {
			case ResolvableOperatorType.CREATE_TABLE: {
				return CREATE_ELEMENT._CREATE_Table_IN_Database_Schema_entites(resolvableOperator);
			}
			case ResolvableOperatorType.RENAME_TABLE: {
				return SET_ATTRIBUTE._SET_ATTRIBUTE_NamedElement_Name(resolvableOperator);
			}
			case ResolvableOperatorType.RENAME_COLUMN: {
				return SET_ATTRIBUTE._SET_ATTRIBUTE_NamedElement_Name(resolvableOperator);
			}
			case ResolvableOperatorType.CREATE_COLUMN: {
				return CREATE_ELEMENT._CREATE_Column_IN_Table_columns(resolvableOperator);
			}
			case ResolvableOperatorType.CREATE_FOREIGN_KEY: {
				return CREATE_ELEMENT._CREATE_ForeignKey_IN_Table_columns(resolvableOperator);
			}
			
			case ResolvableOperatorType.CREATE_INDEX_IN_TABLE: {
				return CREATE_ELEMENT._CREATE_INDEX_IN_Table_constraints(resolvableOperator);
			}
			case ResolvableOperatorType.REMOVE_CONSTRAINT: {
				return DELETE_ELEMENT.DELETE_CONSTRAINT_IN_Table(resolvableOperator); // TODO
			}
			case ResolvableOperatorType.SET_ATTRIBUTE_CONSTRAINT_NAME: {
				return SET_ATTRIBUTE._SET_ATTRIBUTE_UNIQUE_CONSTRAINT_NAME(resolvableOperator); // TODO
			}
			case ResolvableOperatorType.CHANGE_REFERENTIAL_ACTION: {
				return SET_ATTRIBUTE._CHANGE_Literal_ForeignKey(resolvableOperator);
			}
			case ResolvableOperatorType.SET_COLUMN_DEFAULT_VALUE: {
				return SET_ATTRIBUTE._SET_ATTRIBUTE_Column_DefaultValue(resolvableOperator);
			}
			case ResolvableOperatorType.SET_ATTRIBUTE_FOREIGNKEY_CONSTRAINT_NAME: {
				return SET_ATTRIBUTE._CHANGE_ForeignKey_constraint_name(resolvableOperator);
			}
			case ResolvableOperatorType.SET_COLUMN_AUTO_INCREMENT: {
				return SET_ATTRIBUTE._SET_ATTRIBUTE_Column_AutoIncrement(resolvableOperator);
			}
			case ResolvableOperatorType.ADD_COLUMN_TO_INDEX: {
				return SET_ATTRIBUTE._SET_ATTRIBUTE_Column_AutoIncrement(resolvableOperator);
			}
			default: {
				println("Operator does not exists")
			}
		}
	}

	// The operator order does matter
	def String processPartiallyResolvableOperator(PartiallyResolvable partiallyResolvable) {

		switch (partiallyResolvable.displayName) {
			
			case PartiallyResolvableOperatorType.CREATE_PRIMARY_KEY: {
				return CREATE_ELEMENT._CREATE_PrimaryKey_IN_Table_columns(partiallyResolvable);
			}
			
			case PartiallyResolvableOperatorType.SET_COLUMN_SIZE: {
				return SET_ATTRIBUTE._SET_ATTRIBUTE_Column_Size(partiallyResolvable);
			}
			case PartiallyResolvableOperatorType.CREATE_UNIQUE_CONSTRAINT: {
				return CREATE_ELEMENT._CREATE_UNIQUE_INDEX_IN_Table_constraints(partiallyResolvable);
			}
			case PartiallyResolvableOperatorType.SET_COLUMN_TYPE: {
				return SET_ATTRIBUTE._SET_ATTRIBUTE_Column_Type(partiallyResolvable);

			}
			case PartiallyResolvableOperatorType.DELETE_COLUMN: {
				return DELETE_ELEMENT._DELETE_Column_IN_Table_columns(partiallyResolvable);

			}
			case PartiallyResolvableOperatorType.DELETE_FOREIGN_KEY: {
				return DELETE_ELEMENT._DELETE_ForeignKey_IN_Table_columns(partiallyResolvable);

			}
			case PartiallyResolvableOperatorType.DELETE_TABLE: {
				return DELETE_ELEMENT._DELETE_Table_IN_Database_Schema_entites(partiallyResolvable);

			}
			case PartiallyResolvableOperatorType.DELETE_PRIMARY_KEY: {
				return DELETE_ELEMENT._DELETE_PrimaryKey_IN_Table_columns(partiallyResolvable);

			}
			case PartiallyResolvableOperatorType.CHANGE_1N_INTO_NM: {
				return ComplexChanges._CHANGE_1N_INTO_NM(partiallyResolvable);

			}
			case PartiallyResolvableOperatorType.CHANGE_1N_INTO_NM_MOVE: {
				return ComplexChanges._CHANGE_1N_INTO_NM_MOVE(partiallyResolvable);

			}
			case PartiallyResolvableOperatorType.CHANGE_1N_INTO_NM_PRESERVE: {
				return ComplexChanges._CHANGE_1N_INTO_NM_PRESERVE(partiallyResolvable);

			}
			case PartiallyResolvableOperatorType.CHANGE_NM_INTO_1N: {
				return ComplexChanges._CHANGE_NM_INTO_1N(partiallyResolvable);

			}
			case PartiallyResolvableOperatorType.CHANGE_NM_INTO_1N_PRESERVE: {
				return ComplexChanges._CHANGE_NM_INTO_1N_PRESERVE(partiallyResolvable);

			}
			case PartiallyResolvableOperatorType.SET_COLUMN_TYPE_AND_SIZE: {
				return SET_ATTRIBUTE._SET_COLUMN_TYPE_AND_SIZE(partiallyResolvable);

			}
			case PartiallyResolvableOperatorType.SET_COLUMN_NOT_NULL: {
				return SET_ATTRIBUTE._SET_ATTRIBUTE_Column_NotNull(partiallyResolvable);

			}
			default: {
				"-- Operator does not exists"
			}
		}

	}

	def String processNotResolvableOperator(NotAutomaticallyResolvable notAutomaticallyResolvable) {
		switch (notAutomaticallyResolvable.displayName) {
			case NotAutomaticallyResolvableOperatorType.MOVE_COLUMN: {
				return MOVE_ELEMENT._MOVE_Column_FROM_Table_columns_TO_Table_columns(notAutomaticallyResolvable);
			}
			case NotAutomaticallyResolvableOperatorType.MOVE_FOREIGN_KEY: {
				return MOVE_ELEMENT._MOVE_ForeignKey_FROM_Table_columns_TO_Table_columns(notAutomaticallyResolvable);
			}
			case NotAutomaticallyResolvableOperatorType.MOVE_PRIMARY_KEY: {
				return MOVE_ELEMENT._MOVE_PrimaryKey_FROM_Table_columns_TO_Table_columns(notAutomaticallyResolvable);
			}
			case NotAutomaticallyResolvableOperatorType.JOIN_TABLE: {
				return ComplexChanges._JOIN_TABLE(notAutomaticallyResolvable);
			}
			default: {
				println("Operator does not exists")
			}
		}

	}

	/**
	 * Switch case method to identify the different semantic change sets.
	 */
	def String processSemanticChangeSet(SemanticChangeSet set) {

		switch (set.name) {
			// SET
			case 'SET_ATTRIBUTE_PrimaryKey_PrimaryKey': {
				return SET_ATTRIBUTE._SET_ATTRIBUTE_PrimaryKey_PrimaryKey(set);

			}
			case 'SET_ATTRIBUTE_ForeignKey_PrimaryForeignKey': {
				return SET_ATTRIBUTE._SET_ATTRIBUTE_ForeignKey_PrimaryForeignKey(set);

			}
		// MOVE 
		}

		return "";

	}

	def String javaToSQLType(String type) {
		switch (type) {
			case "java.lang.String": {
				return "varchar(255)"
			}
			case "java.lang.Integer": {
				return "bigint(20)"
			}
			case "java.lang.Long": {
				return "bigint(20)"
			}
			case "long": {
				return "bigint(20)"
			}
			case "java.lang.Boolean": {
				return "tinyint(1)"
			}
			case "java.util.Date": {
				return "datetime"
			}
			case "byte[]": {
				return "longblob"
			}
			default: {
				return "varchar(255)" // TODO Enum usw.
			}
		}
	}

	def void checkCircleInDisplayNamePath(EClass current, EClass start, List<EClass> path) {
		if (start.equals(current)) {
			throw new RuntimeException(
				"Circle detected in DisplayName-path starting in EClass: " + current.name + ". Path is: " + path)
		}
		if (current !== null) {
			path.add(current)
		}
		var EClass tmp = current
		if (tmp === null) {
			tmp = start
		}
		for (a : tmp.EAllReferences.filter[EAnnotations.exists[source.equals(DISPLAY_NAME)]]) {
			checkCircleInDisplayNamePath(a.EReferenceType, start, path)
		}
	}

	/**
	 * @param migration The method checks if the migration contains 
	 * operators with a possible breaking influence on existing data.
	 */
	def boolean isHistoryTableRequired(Migration migration) {

		if (migration.notAutimaticallyResolvable.size > 0)
			return true;

		for (PartiallyResolvable partiallyResolvable : migration.partiallyResovableSMO) {

			if (partiallyResolvable.processStatus === ProcessStatus.RESOLVED) {
				if (partiallyResolvable.resolveOptions !== ColumnOptions.IGNORE)
					return true;

			}

		}

		return false;
	}

	def void makeProgressAndCheckCanceled(IProgressMonitor monitor) {
		if (monitor.canceled) {
			throw new GenerationCanceledException
		}
		monitor.worked(1)
		worked++
		var int done = ((worked as double / work as double) * 100.0) as int
		monitor.taskName = "Generating code... " + done + "%"
	}

	/**
	 * Returns {@code true} if the given EClass is annotated with the {@link #ASSOCIATION_CLASS} annotation. In this case, the given EClass is an association class.
	 */
	def boolean isAssociationClass(EClass e) {
		return e.EAnnotations.exists[source.equals(ASSOCIATION_CLASS)]
	}

	def boolean isAssociationEnd(EReference ref) {
		return ref.EAnnotations.exists[source.equals(ASSOCIATION_END)]
	}

	/**
	 * Creates a file of the given content in the given folder. If the folder does not exist, it will be created.
	 */
	def void createFile(IFolder folder, String fileName, boolean overrideFile, CharSequence content,
		IProgressMonitor progressMonitor) {
		if (progressMonitor.canceled) {
			throw new GenerationCanceledException
		}

		if (!folder.exists()) {
			folder.create(true, true, null);
		}

		var IFile iFile = folder.getFile(fileName);

		if (overrideFile == false && iFile.exists) {
			return;
		}
		if (!iFile.exists) {
			iFile.create(null, true, null);
		}

		// count character
		character += content.length

		// process the code
		var String formattedCode
//		if (fileName.endsWith(".java")) {
//			// organize imports
//			// count for stats
//			val char semicolon = ';'
//			val contentString = content.toString
//			val char[] charArray = contentString.toCharArray
//			for (char c : charArray) {
//				if (c == semicolon) {
//					statements++
//				}
//			}
//			lineSeparators += contentString.split(System.lineSeparator).length
		// TODO im not generating java code
		// var String sourceWithImports = importFinder.getWithImports(content.toString)
		// format the java code
		// formattedCode = JavaFormatter.format(sourceWithImports)
//		} else if (fileName.endsWith(".xml")) {
//			// format the xml code
//			formattedCode = XmlFormatter.format(content.toString)
//		}
		var byte[] bytes
		if (formattedCode !== null) { // has the code been formatted?
			bytes = formattedCode.getBytes()
		} else { // code could not be formatted
			bytes = content.toString.bytes
			System.err.println("File " + fileName + " could not be formatted.")
		}
		// save the file
		var InputStream source = new ByteArrayInputStream(bytes)
		generatedFiles++
		generatedBytes += bytes.size
		iFile.setContents(source, IResource.FORCE, null)
	}

}
